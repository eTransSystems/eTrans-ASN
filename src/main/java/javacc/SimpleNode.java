/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package javacc;

import java.io.*;
import java.util.List;
import java.util.Vector;

public
class SimpleNode implements Node {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected AsnParser parser;
  protected Token firstToken;
  protected Token lastToken;
    protected String moduleId;

  protected List<ASTElementType> elementsWithClasses = new Vector<ASTElementType>();

    public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(AsnParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  public Token jjtGetFirstToken() { return firstToken; }
  public void jjtSetFirstToken(Token token) { this.firstToken = token; }
  public Token jjtGetLastToken() { return lastToken; }
  public void jjtSetLastToken(Token token) { this.lastToken = token; }

  /** Accept the visitor. **/
  public Object jjtAccept(AsnParserVisitor visitor, Object data)
{
    return visitor.visit(this, data);
  }

  /** Accept the visitor. **/
  public Object childrenAccept(AsnParserVisitor visitor, Object data)
{
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);
      }
    }
    return data;
  }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() {
    return AsnParserTreeConstants.jjtNodeName[id];
  }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

    public int getId() {
    return id;
  }

    /**
     * Get the module id for this node.  Will recurse and store value the first time.
     * @return The module id.
     */
    public String getModuleId(){
        if (moduleId == null) {
            moduleId = ((SimpleNode)jjtGetParent()).getModuleId();
        }
        return moduleId;
    }

    /**
     * Subclasses can override this to handle directives that need specific information.
     * @param outputStream Output stream to write to.
     * @param directiveName The directive name to be handled.
     * @param line A StringBuffer with the current line.  It can be replaced if necessary.
     * @return Return true if the directive was handles and false otherwise.
     */
    protected boolean generateClassDirectiveText( OutputStream outputStream, String directiveName, StringBuffer line) throws IOException {
        return false;
    }

    /**
     * Generates the class definition inside a file.
     * @param name Name of the class.
     * @param templatePrefix Template to use for class content.
     */
    protected void generateClass(String name, String templatePrefix) {
        name = name.replace('-','_'); // always normalize the file name
        StringBuilder filename = new StringBuilder();
        if(AsnParser.outputDirectory != null) {
            filename.append(AsnParser.outputDirectory + System.getProperty("file.separator"));
        }
        // use the module to determine the java package and output directory
        filename.append( getModuleId().toLowerCase() + System.getProperty("file.separator") );

        // create the directory if necessary
        File directory = new File(filename.toString());
        if (!directory.exists()) {
            directory.mkdir();
        }

        filename.append(name + ".java");
        String modId = getModuleId();

        OutputStream os = null;
        try {
            os = new FileOutputStream(filename.toString());
            writeClass( os, name, templatePrefix );
            os.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Writes the class definition to an open output stream.
     * @param os The output stream to write to.
     * @param name Name of the class.
     * @param templatePrefix  Template to use for class content.
     */
    protected void writeClass(OutputStream os, String name, String templatePrefix)
    {
        //added by fatih Batuk
        name = name.replace('-','_'); // always normalize the file name
        try
        {
            String templateName = "META-INF/templates/" + templatePrefix + ".template";
            InputStream inputStream = getClass().getClassLoader().getResourceAsStream(templateName );
            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

            String line;
            while(true)
            {
                line = reader.readLine();
                if(line == null)
                    break;

                while(true)
                {
                    int idx = line.indexOf('@');
                    if(idx == -1)
                        break;

                    int ndx = line.indexOf('@', idx + 1);	// look for the closing symbol
                    if(ndx == -1)
                        break;

                    String directive = line.substring(idx + 1, ndx);
                    if(directive.equals("name"))	// replace with the class name
                    {
                        String left = line.substring(0, idx);
                        String right = line.substring(ndx + 1);
                        line = new String(left + name + right);
                        continue;
                    }

                    if(directive.equals("package"))	// insert the package for this class
                    {
                        if(AsnParser.outputPackage != null)
                            line = new String("package " + AsnParser.outputPackage + "." + getModuleId().toLowerCase() + ";");
                        else
                            line = "";

                        continue;
                    }

                    if(directive.equals("elements"))	// insert a list of declarations
                    {
                        String[] declarations = getElementDeclarations();
                        if (declarations != null) {
                            for (int i = 0; i < declarations.length; i++) {
                                os.write(declarations[i].getBytes());
                                os.write(0x0a);
                                os.flush();
                            }
                            line = "\t/* end of element declarations */";
                        } else {
                            line = "";  // some inner classes may not have elements
                        }
                        continue;
                    }

                    if(directive.equals("setupelements"))	// insert a list tagging setup statements
                    {
                        String[] setup = setupElements();
                        if (setup != null) {
                            for (int i = 0; i < setup.length; i++) {
                                os.write(setup[i].getBytes());
                                os.write(0x0a);
                                os.flush();
                            }
                            line = "\t/* end of element setup */";
                        } else {
                            line = "";  // some inner classes may not have elements
                        }
                        continue;
                    }

                    if(directive.equals("elementclasses"))	// set up inner classes for elements that are defined in sequences
                    {
                        line = "";
                        if (elementsWithClasses.size() > 0) {
                            for (ASTElementType et : elementsWithClasses) {
                                et.writeInnerClass(os, et.getClassName());
                                os.write(0x0a);
                            }
                            line = "\t// END element classes";
                        }
                        continue;
                    }

                    StringBuffer lineToPass = new StringBuffer( line );
                    if (generateClassDirectiveText(os, directive, lineToPass)) {
                        // if it was handled then use the line that was modified
                        line = lineToPass.toString();
                        continue;
                    }
                }

                os.write(line.getBytes());
                os.write(0x0a);
            }

            os.flush();
            reader.close();
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Should be overriden by classes that generate inner classes.
     * @return The template name to use.
     */
    protected String getInnerClassTemplateName() {
        return null;
    }

    protected void writeInnerClass(OutputStream outputStream, String className)
    {
        // TODO - Many not always be sequence, could be set I believe
        writeClass(outputStream, className, getInnerClassTemplateName());
    }

    public String
    getClassNameForDefinedType()
    {
        for(int i = 0; i < jjtGetNumChildren(); i++)
        {
            Node n = jjtGetChild(i);
            if(n instanceof ASTDefinedType == true)
            {
                StringBuilder retVal = new StringBuilder();
                // check for module name as well
                for(int j = 0; j < n.jjtGetNumChildren(); j++) {
                    Node n1 = n.jjtGetChild(j);
                    if (n1 instanceof ASTmodulereference) {
                        if(AsnParser.outputPackage != null) {
                            retVal.append( AsnParser.outputPackage + "." );
                        }
                        retVal.append(((ASTmodulereference)n1).jjtGetFirstToken().image.toLowerCase() + ".");
                    }
                }
                retVal.append(((ASTDefinedType)n).getClassName());
                return retVal.toString();
            }
        }

        return null;
    }

    /**
     * Get the list of elements for this node.  May be overridden by subclasses.
     * @return Vector with the list of element nodes.
     */
    protected Vector<ASTElementType> getElements() {
        Vector<ASTElementType> retVal = new Vector<ASTElementType>();
        int numChildren = jjtGetNumChildren();
        for(int i = 0; i < numChildren; i++) {
            Node n = jjtGetChild(i);
            if (n instanceof ASTElementType) {
                retVal.add((ASTElementType)n);
            }
        }
        return retVal;
    }

    /**
     *
     * @return An array of lines to use in the generated file to declare the elements.
     */
    private String[]
    getElementDeclarations()
    {
        Vector<ASTElementType> elementList = getElements();
        if (elementList.size() > 0) {
            Vector decs = new Vector();
            for (ASTElementType et : elementList) {
                boolean isComposite = et.isComposite();
                String eName;
                String eType = et.getClassName();
                if (eType != null) { // could be null if this is a placeholder, like ...
                    eType = eType.replace('-', '_');
                    eName = et.getName();
                    eName = eName.replace('-', '_');

                    if (isComposite) {
                        elementsWithClasses.add(et);
                    }

                    //Changed from private visibility to public visibility by Fatih Batuk
                    String dec = new String("\tpublic " + eType + " " + eName + " = new " + eType + "(\"" + eName + "\");");
                    decs.addElement(dec);
                }
            }
            String[] rc = new String[decs.size()];
            decs.toArray(rc);
            return rc;
        }
        return null;
    }

    /**
     * Sets up the text to setup elements in the template. Added here as multiple classes use it.
     * @return An array of lines to use in the generated file to set up elements inside a method.
     */
    private String[]
    setupElements()
    {
        Vector<ASTElementType> elementList = getElements();
        if (elementList.size() > 0) {
            Vector decs = new Vector();
            for (ASTElementType et : elementList) {
                String eName;
                String eType = et.getClassName();
                int tagNumber = et.getTagNumber();
                if (eType != null) { // could be null if this is a placeholder, like ...
                    eName = et.getName();
                    eName = eName.replace('-', '_');

                    /*
                     * For each element, check optional status, default value (later), tagging method, class and number
                     */

                    decs.addElement(new String("\t\tsuper.addElement(" + eName + ");"));

                    // optional status
                    if (et.isOptional() == true) {
                        decs.addElement(new String("\t\t" + eName + ".setOptional(true);"));
                    }

                    // tag number
                    // this seems to be required for it to work as expected
                    // assuming that method defines tagNumber value for use
                   // decs.addElement(new String("\t\t" + eName + ".setTagNumber( tagNumber ++ );"));
                    //Modify by Mark, change tage number to asn.1 file defined number
                    decs.addElement(new String("\t\t" + eName + ".setTagNumber(" + tagNumber + ");"));

                    // tagging method
                    if (et.isTagged() != true)
                        continue;

                    int tm = et.getTaggingMethod();
                    if (tm == ASTTaggedType.EXPLICIT)
                        decs.addElement(new String("\t\t" + eName + ".setTaggingMethod(Tag.EXPLICIT);"));    //modified by Fatih Batuk (changed "ASN1Object" to word "Tag")
                    else
                        decs.addElement(new String("\t\t" + eName + ".setTaggingMethod(Tag.IMPLICIT);"));    //modified by Fatih Batuk (changed "ASN1Object" to word "Tag")

                    // tag class
                    int tc = et.getTagClass();
                    switch (tc) {
                        case ASTTaggedType.CONTEXT:
                            decs.addElement(new String("\t\t" + eName + ".setTagClass(Tag.CONTEXT);"));        //modified by Fatih Batuk (changed "ASN1Object" to word "Tag")
                            break;
                        case ASTTaggedType.APPLICATION:
                            decs.addElement(new String("\t\t" + eName + ".setTagClass(Tag.APPLICATION);"));    //modified by Fatih Batuk (changed "ASN1Object" to word "Tag")
                            break;
                        case ASTTaggedType.PRIVATE:
                            decs.addElement(new String("\t\t" + eName + ".setTagClass(Tag.PRIVATE);"));        //modified by Fatih Batuk (changed "ASN1Object" to word "Tag")
                            break;
                    }
                }
            }
            String[] rc = new String[decs.size()];
            decs.toArray(rc);
            return rc;
        }
        return null;
    }
}

/* JavaCC - OriginalChecksum=bc51fa56f42c2184ba690912a93e8f5e (do not edit this line) */
